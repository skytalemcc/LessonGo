### 0.0.1 常见golang命令
go version  golang自身版本  
go fmt 格式化代码包的格式，注意不包含子代码包  
go run 编译并执行，只能作用于源码文件，一般用作开发中快速测试  
go build 直接使用，则代表编译当前目录所对应的代码包，并生成和目录名一样的编译文件。如果指定源码文件，则编译成源码文件对应的编译文件  
go语言的源码文件分为三类，包括命令源码文件，库源码文件，测试源码文件，包含main的文件或者包时候，则生成可执行文件，否则，只做检查性编译  
go install 编译安装，将编译后生成的执行文件放到工程目录的bin目录下，将生成的归档文件(即静态链接库)存放到工程目录的pkg目录下，工程目录即gopath目录下生成bin和pkg文件夹。一般是执行子文件夹。  
go clean 删除执行其它命令时产生的文件和目录  
go test 进行单元测试的工具，单元测试代码建议与被测试代码放到同一个包中，并以_test结尾。单元测试案例中可以有多个测试用例，测试用例函数需要以Test为前缀，测试用例本身不参与正常代码编译，不包含到编译文件中，使用此命令，不需main作为入口。所有在以_test结尾的源码内以Test开头的函数会自动被执行  
go get 下载第三方代码包并编译安装，它会下载到gopath环境配置的第一个工作区  
go list -json 显示指定包的导入路径  
go fix 当go语言升级的时候或升级第三方代码包的时候，把代码包中旧的语法更新为新版本的语法的工具  
go vet 静态检查工具，一般项目快完成进行优化  
go tool pprof 性能检查工具  
go env 打印go语言环境信息，gopath 工作区目录，goroot 语言的安装目录，gobin 是通过go install命令生成的可执行文件的存放目录(默认为当前工作区的bin目录下)  

Go的项目目录管理：  
src包含项目的源代码  
pkg包含编译后生成的包和库文件  
bin包含编译后生成的可执行文件  

Go的工程管理总结：  
一定要管理好目录，多个项目最好都在一个gopath下面，即gopath/src/proj1，gopath/src/proj2。   
尽量使用goinstall ，这样能够规范项目的整体结构。一个项目目录下，多个文件，最好只有一个main函数。  
多个项目的时候可以使用Make来进行编译，来选择gopath目录，来编译。  
src下面有多个项目，src平级的目录 有bin和pkg目录。想要构建每一个项目，就要把多个项目目录添加到gopath里面，多个项目用;分号分开。  

### 0.0.2 Go语言圣经
Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。  
并发研究的基础文献 顺序通信进程(communicating sequential processes ，缩写为CSP)。在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。    
所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。  
“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。  
简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应。  
语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。  
Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误。Go语言的类型系统相比传统的强类型语言又要简洁很多。  
Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。  
Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。  
入门：  
Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。  
Go语言提供的工具都通过一个单独的命令go调用，go命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。  
Go语言原生支持Unicode，它可以处理全世界任何语言的文本。  
Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条package声明语句开始。  
main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main 函数 也很特殊，它是整个程序执行时的入口。main函数所做的事情就是程序做的。  
一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。  
Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式。  
程序结构:  
1，命名：  
Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的。  
25个关键字：  
break      default       func     interface   select  
case       defer         go       map         struct  
chan       else          goto     package     switch  
const      fallthrough   if       range       type  
continue   for           import   return      var  
预定义的名字，主要对应内建的常量、类型和函数  
内建常量: true false iota nil  
内建类型: int int8 int16 int32 int64  
          uint uint8 uint16 uint32 uint64 uintptr  
          float32 float64 complex128 complex64  
          bool byte rune string error  
内建函数: make len cap new append copy close delete  
          complex real imag  
          panic recover  
如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的，也就是说可以被外部的包访问。包本身的名字一般总是用小写字母。  
通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。  
在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。  
2，声明:  
声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。
一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。  
一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。  
3，变量:  
var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。 var 变量名字 类型 = 表达式  
如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。  
在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。  
因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。  
指针是一个变量对应一个保存了变量对应类型值的内存空间。一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字。  
变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。  
那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。  
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。  
你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。  
Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。  
4,赋值  
使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。  
赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量。  
不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。  
对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。  
5，类型  
变量或表达式的类型定义了对应存储值的属性特征。一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。type 类型名字 底层类型 。类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用。命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。  
6，包和文件  
Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径。每个包都对应一个独立的名字空间。包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言程序中，每个包都有一个全局唯一的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时，一个导入路径代表一个目录中的一个或多个Go源文件。 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数。每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。  
7，作用域  
一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都对应词法块；每个switch或select的分支也有独立的语法块；当然也包括显式书写的词法块（花括弧包含的语句）。  
声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。  
控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。  
一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。  


